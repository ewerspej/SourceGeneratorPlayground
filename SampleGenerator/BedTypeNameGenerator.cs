using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;

namespace SampleGenerator;

[Generator]
public class BedTypeNameGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var syntaxProvider = context.SyntaxProvider.CreateSyntaxProvider(
                (syntaxNode, _) => syntaxNode is ClassDeclarationSyntax,
                (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
            .Where(c => c is not null && c.Identifier.Text.EndsWith("Bed"));

        var compilation = context.CompilationProvider.Combine(syntaxProvider.Collect());

        context.RegisterSourceOutput(compilation, Execute);
    }

    private void Execute(SourceProductionContext context, (Compilation Left, ImmutableArray<ClassDeclarationSyntax> Right) compilationTuple)
    {
        var (compilation, bedClasses) = compilationTuple;

        var list = new List<string>();

        foreach (var bedClass in bedClasses)
        {
            list.Add(bedClass.Identifier.Text);
        }

        var classDeclarations = list.Select(bedClass => $"public const string {bedClass} = \"{bedClass}\";");
        var classDeclarationsString = string.Join("\n    ", classDeclarations);

        var source = $$"""
                       // <auto-generated/>
                       namespace {{compilation.GetEntryPoint(context.CancellationToken)?.ContainingNamespace.ToDisplayString()}};

                       public static class BedTypes
                       {
                           {{classDeclarationsString}}
                           
                           public static List<string> AllBedTypes = new()
                           {
                               {{string.Join(",\n        ", list)}}
                           };
                       }
                       """;

        context.AddSource("BedTypes.g.cs", source);
    }
}